default_platform(:mac)

# Static configuration for the Mac desktop app
require 'json'
require 'base64'
require 'timeout'

APP_CONFIG = {
  app_identifier: "com.bitwarden.desktop",
  release_notes_path: "fastlane/release_notes",
  locales: ["ca", "zh-Hans", "zh-Hant", "da", "nl-NL", "en-US", "fi", "fr-FR", "de-DE", "id", "it", "ja", "ko", "no", "pt-PT", "pt-BR", "ru", "es-ES", "es-MX", "sv", "tr", "vi", "en-GB", "th"]
}

platform :mac do
  desc "Prepare release notes from changelog"
  lane :prepare_release_notes do |options|
    changelog = options[:changelog] || "Bug fixes and improvements"
    
    # Create metadata directories and files for all locales
    APP_CONFIG[:locales].each do |locale|
      dir = "metadata/#{locale}"
      FileUtils.mkdir_p(dir)
      File.write("#{dir}/release_notes.txt", changelog)
      UI.message("Creating release notes for #{locale}")
    end

    # Create release notes hash for deliver
    notes = APP_CONFIG[:locales].each_with_object({}) do |locale, hash|
      file_path = "metadata/#{locale}/release_notes.txt"
      if File.exist?(file_path)
        hash[locale] = File.read(file_path)
      else
        UI.important("No release notes found for #{locale} at #{file_path}, skipping.")
      end
    end
    
    UI.success("‚úÖ Prepared release notes for #{APP_CONFIG[:locales].count} locales")
    notes
  end

  desc "Display configuration information"
  lane :show_config do |options|
    build_number = (options[:build_number] || ENV["BUILD_NUMBER"]).to_s.strip
    app_version = (options[:app_version] || ENV["APP_VERSION"]).to_s.strip
    
    UI.message("üì¶ App ID: #{APP_CONFIG[:app_identifier]}")
    UI.message("üè∑Ô∏è Version: #{app_version.empty? ? '(not set)' : app_version}")
    UI.message("üî¢ Build Number: #{build_number}")
    UI.message("üåç Locales: #{APP_CONFIG[:locales].count}")
  end

  # Quick existence check (no polling) for the specific macOS build in App Store Connect
  private_lane :assert_build_exists do |options|
    require 'spaceship'

    app_identifier = APP_CONFIG[:app_identifier]
    app_version = options[:app_version].to_s.strip
    build_number = options[:build_number].to_s.strip

    UI.message("üîé Checking for MAC_OS build #{app_identifier} #{app_version} (#{build_number}) in App Store Connect...")

    app = Spaceship::ConnectAPI::App.find(app_identifier)
    UI.user_error!("App not found in App Store Connect: #{app_identifier}") unless app

    # Use App Store versions API (supported) to confirm the version exists
    debug = ENV["ASC_DEBUG"] == "1"
    app_store_version = nil
    attempts = 0
    begin
      attempts += 1
      UI.message("üì° Fetching App Store versions (MAC_OS)‚Ä¶ attempt #{attempts}")
      vers = nil
      started = Time.now
      Timeout.timeout(90) { vers = app.get_app_store_versions(limit: 50) }
      UI.message("‚úÖ App Store versions fetched in #{(Time.now - started).round(2)}s (#{(vers || []).size} total)")
      app_store_version = (vers || []).find { |v| v.platform == "MAC_OS" && v.version_string == app_version }
    rescue Timeout::Error => e
      UI.important("‚è≥ Timeout while fetching App Store versions (attempt #{attempts})")
      UI.important("    Error: #{e.class}: #{e.message}") if debug
      retry if attempts < 2
    rescue StandardError => e
      UI.important("‚ö†Ô∏è Error fetching App Store versions: #{e.class}: #{e.message}")
      UI.important(e.backtrace.first(3).join("\n")) if debug
    end

    if app_store_version
      UI.message("üîó Found AppStoreVersion id=#{app_store_version.id} version=#{app_store_version.version_string} platform=#{app_store_version.platform}") if debug
    else
      UI.important("‚ö†Ô∏è Could not confirm App Store version via API; continuing")
    end

    # Fetch builds for the app and filter by preReleaseVersion + build number
    builds = nil
    attempts = 0
    begin
      attempts += 1
      UI.message("üì° Fetching builds for app (limit 200)‚Ä¶ attempt #{attempts}")
      started = Time.now
      Timeout.timeout(120) { builds = app.get_builds(includes: "preReleaseVersion", limit: 200) }
      UI.message("‚úÖ Builds fetched in #{(Time.now - started).round(2)}s (#{(builds || []).size} returned)")
    rescue Timeout::Error => e
      UI.important("‚è≥ Timeout while fetching builds (attempt #{attempts})")
      UI.important("    Error: #{e.class}: #{e.message}") if debug
      retry if attempts < 2
      UI.important("Proceeding without build pre-check due to App Store Connect slowness")
      builds = []
    rescue StandardError => e
      UI.important("‚ö†Ô∏è Error fetching builds: #{e.class}: #{e.message}")
      UI.important(e.backtrace.first(3).join("\n")) if debug
      UI.important("Proceeding without build pre-check due to error fetching builds")
      builds = []
    end

    # Log a few candidates for visibility
    (builds || []).first(10).each do |b|
      app_ver = b.pre_release_version&.version || "?"
      build_ver = b.version || "?"
      UI.message("  ‚Ä¢ AppVersion=#{app_ver} Build=#{build_ver} state=#{b.processing_state}")
    end

    found = (builds || []).find { |b| b.pre_release_version&.version == app_version && b.version.to_s == build_number }
    if found
      UI.success("‚úÖ Found AppVersion=#{app_version} Build=#{found.version} state=#{found.processing_state}")
    else
      UI.important("‚ö†Ô∏è Could not confirm build presence via API; continuing to deliver with app_version=#{app_version} build_number=#{build_number}")
    end
  end

  # Explicitly select a build for the App Store version (macOS workaround)
  private_lane :select_build_for_version do |options|
    require 'spaceship'
    
    app_version = options[:app_version].to_s.strip
    build_number = options[:build_number].to_s.strip
    
    UI.message("üîó Checking if build #{build_number} is selected for version #{app_version}...")
    
    app = Spaceship::ConnectAPI::App.find(APP_CONFIG[:app_identifier])
    return unless app
    
    # Find the App Store version
    versions = app.get_app_store_versions(limit: 50)
    app_store_version = versions.find { |v| v.platform == "MAC_OS" && v.version_string == app_version }
    
    unless app_store_version
      UI.important("‚ö†Ô∏è App Store version not found: #{app_version} (MAC_OS)")
      return
    end
    
    # Check if build is already linked
    begin
      current_build = app_store_version.build
      if current_build && current_build.version.to_s == build_number
        UI.success("‚úÖ Build #{build_number} is already selected for version #{app_version}")
        return
      end
    rescue StandardError => e
      UI.message("Could not check current build: #{e.message}")
    end
    
    # Find and select the build
    builds = app.get_builds(includes: "preReleaseVersion", limit: 200)
    build = builds.find { |b| b.pre_release_version&.version == app_version && b.version.to_s == build_number }
    
    unless build
      UI.user_error!("‚ùå Build not found: #{app_version} (#{build_number})")
    end
    
    # Check build is in valid state
    if build.processing_state != "VALID"
      UI.user_error!("‚ùå Build #{build_number} is not in VALID state (current: #{build.processing_state})")
    end
    
    # Try to select the build using the Spaceship API
    begin
      # Use the Spaceship ConnectAPI method to update the build relationship
      Spaceship::ConnectAPI.patch_request(
        "appStoreVersions/#{app_store_version.id}/relationships/build",
        body: {
          data: {
            type: "builds",
            id: build.id
          }
        }
      )
      UI.success("‚úÖ Successfully selected build #{build_number} for version #{app_version}")
    rescue StandardError => e
      UI.user_error!("‚ùå Failed to select build: #{e.message}. This might be a fastlane/macOS platform issue.")
    end
  end

  # Post-submit verification that the App Store version has a build linked
  private_lane :verify_build_linked do |options|
    require 'spaceship'

    app_identifier = APP_CONFIG[:app_identifier]
    app_version = options[:app_version].to_s.strip
    build_number = options[:build_number].to_s.strip

    UI.message("üîé Verifying build linkage for #{app_identifier} #{app_version} (#{build_number})‚Ä¶")

    app = Spaceship::ConnectAPI::App.find(app_identifier)
    unless app
      UI.important("‚ö†Ô∏è App not found for verification: #{app_identifier}")
      next
    end

    versions = nil
    begin
      Timeout.timeout(60) do
        # Attempt to include build relationship for fewer round-trips
        versions = app.get_app_store_versions(limit: 50, includes: "build")
      end
    rescue StandardError => e
      UI.important("‚ö†Ô∏è Error fetching App Store versions for verification: #{e.class}: #{e.message}")
      versions = app.get_app_store_versions(limit: 50) rescue []
    end

    asv = (versions || []).find { |v| v.platform == "MAC_OS" && v.version_string == app_version }
    unless asv
      UI.important("‚ö†Ô∏è Could not find App Store version #{app_version} (MAC_OS) for verification")
      next
    end

    begin
      build = asv.build
    rescue StandardError
      # Some fastlane versions lazy-load this; fall back to fetching
      build = nil
    end

    if build.nil?
      UI.important("‚ùå No build is currently linked to App Store version #{app_version} (MAC_OS).")
      UI.important("   If this persists, we may need to explicitly set the build relation via API.")
    else
      linked_bn = build.version.to_s
      linked_av = build.pre_release_version&.version
      if linked_bn == build_number && linked_av == app_version
        UI.success("‚úÖ Verified: build #{linked_bn} is linked to version #{app_version} (MAC_OS)")
      else
        UI.important("‚ö†Ô∏è A different build appears linked: appVersion=#{linked_av} build=#{linked_bn}")
      end
    end
  end

  desc "Publish desktop to the Mac App Store"
  lane :publish do |options|
    build_number = (options[:build_number] || ENV["BUILD_NUMBER"]).to_s.strip
    app_version = (options[:app_version] || ENV["APP_VERSION"]).to_s.strip
    changelog = options[:changelog] || "Bug fixes and improvements"
    submit_for_review = options[:submit_for_review] == "true" || options[:submit_for_review] == true
    is_dry_run = options[:dry_run] == "true" || options[:dry_run] == true
    
    if is_dry_run
      UI.header("üß™ DRY RUN: Testing Bitwarden Desktop App Store submission")
    else
      UI.header("üöÄ Publishing Bitwarden Desktop to Mac App Store")
    end
    
    # Show configuration info
    show_config(build_number: build_number, app_version: app_version)
    
    # Validate app_version
    UI.user_error!("‚ùå APP_VERSION is required") if app_version.nil? || app_version.empty?
    # Validate build_number
    UI.user_error!("‚ùå BUILD_NUMBER is required") if build_number.nil? || build_number.empty?
    
    # Prepare release notes for all locales
    notes = prepare_release_notes(changelog: changelog)
    
    if is_dry_run
      UI.important("üß™ DRY RUN MODE - Skipping actual App Store Connect submission")
      UI.message("‚úÖ Validation passed")
      UI.message("‚úÖ Release notes prepared for #{APP_CONFIG[:locales].count} locales")
      UI.message("‚úÖ Release notes: #{changelog[0,100]}#{changelog.length > 100 ? '...' : ''}")
      UI.success("üéØ DRY RUN COMPLETE - Everything looks ready for production!")
      next # Use 'next' instead of 'return' in fastlane lanes
    end

    # Set up App Store Connect API
    app_store_connect_api_key(
      key_id: "6TV9MKN3GP",
      issuer_id: ENV["APP_STORE_CONNECT_TEAM_ISSUER"],
      key_content: Base64.encode64(ENV["APP_STORE_CONNECT_AUTH_KEY"]),
      is_key_content_base64: true
    )

    UI.message("üéØ Intending to select build #{build_number} for version #{app_version} (platform: osx)")

    # Ensure the exact MAC_OS build exists before deliver tries to select it
    assert_build_exists(app_version: app_version, build_number: build_number)

    # Release notes already prepared and returned from prepare_release_notes lane
    UI.message("üìù Using release notes for #{notes.keys.count} locales")


    # Upload to App Store Connect
    deliver(
      platform: "osx",
      app_identifier: APP_CONFIG[:app_identifier],
      app_version: app_version,
      build_number: build_number,
      metadata_path: "metadata",
      skip_binary_upload: true,
      skip_screenshots: true,
      skip_metadata: false, 
      release_notes: notes,
      edit_live: false,
      submit_for_review: submit_for_review,
      phased_release: true, # Enable 7-day phased rollout
      precheck_include_in_app_purchases: false,
      run_precheck_before_submit: false,
      automatic_release: true,
      force: true
    )
    
    # Explicitly select the build for macOS (workaround for platform-specific issue)
    select_build_for_version(app_version: app_version, build_number: build_number)
    
    # Verify that the requested build is linked to the App Store version
    verify_build_linked(app_version: app_version, build_number: build_number)

    if submit_for_review
      UI.success("üéâ Successfully submitted Bitwarden Desktop #{app_version} #{build_number} for App Store review!")
    else
      UI.success("üì§ Successfully uploaded Bitwarden Desktop #{app_version} #{build_number} to App Store Connect")
    end
  end
end
